## LSM树

当代数据存储引擎主要基于两类数据结构，B+树和LSM树。

传统的SQL数据库(例如BerkeleyDB)主要基于B+树结构，B+树的读性能好，一次读取通常只需一次磁盘I/O操作，

但B+树的写入性能相对差，一次写入常常需要多次随机磁盘I/O操作。

和B+树不同，LSM树是一种写优化的数据结构，LSM利用磁盘顺序写性能远好于随机写这一事实，将随机写转变为顺序批量写。

简化的LSM树有两个部件组成(Figure 1)，C0和C1部件，C0部件驻留在内存，C1部件驻留在磁盘上，C0和C1都可以是B+树，

写操作都发生在C0部件，基本是纯内存操作，性能高；

当C0树的大小超过一定的阀值，它就会和磁盘上C1树进行合并(compaction)，合并成更大的一颗C1树，读操作从C0树开始查找，如未找到则继续查找C1树

。扩展的LSM树一般有多(K)个部件(Figure 2)组成，除C0驻留内存，其它则以新鲜度分层(Level)方式驻留磁盘，

每一层都有大小限制，归并时从Ci到Ci+1向下归并。

随着层次的增加，LSM树在查找时所需检查的层次就会变多，所以总体LSM树的读性能要低于写性能，

但有一些优化的手段，比如增加布隆过滤器(Bloom Filter)，来有效减少读取时所需查找的部件数量。

当前流行的HBase，Cassandra，LevelDB等NoSQL数据库的核心存储引擎都是基于LSM树的思想发展而来的。
